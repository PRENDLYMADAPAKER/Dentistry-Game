<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dental Game (upgraded)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#f5f7fb;color:#222}
    header{background:#0b6ef6;color:#fff;padding:12px 16px}
    .wrap{max-width:920px;margin:18px auto;padding:16px;background:#fff;border-radius:10px;box-shadow:0 6px 22px rgba(10,20,40,.06)}
    .row{display:flex;gap:12px;align-items:center}
    button{cursor:pointer;border:0;background:#0b6ef6;color:#fff;padding:8px 12px;border-radius:8px}
    .home-btn{background:#6c757d}
    .muted{opacity:.5}
    .controls{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    .game-area{margin-top:12px}
    .options{display:flex;flex-direction:column;gap:8px;margin-top:10px}
    .option-btn{padding:10px;border-radius:8px;border:1px solid #ddd;background:#fafafa;text-align:left}
    .indicator{margin-left:12px;font-weight:600}
    .small{font-size:13px;color:#666}
    #wordsList{white-space:pre-wrap; max-height:260px; overflow:auto; background:#fafafa;padding:8px;border-radius:6px;border:1px dashed #eee}
    footer{font-size:12px;color:#666;margin-top:12px}
  </style>
</head>
<body>
  <header>
    <strong>Dental Game — Upgraded</strong>
  </header>

  <main class="wrap">
    <div class="controls">
      <button id="btnWordscapes">Wordscapes</button>
      <button id="btnQuiz">Quiz</button>
      <button id="btnCases">Cases</button>

      <div style="flex:1"></div>

      <button id="btnPlayAudio" class="home-btn">Play Audio</button>
      <button id="btnToggleMute" class="home-btn muted">Mute</button>
    </div>

    <section id="homeScreen">
      <h3>Home — Data & Controls</h3>
      <p class="small">Make sure this file and the .json files are served from a web server (e.g. `http://localhost:8000/`) so the JSON can be fetched.</p>

      <div style="display:flex;gap:12px;margin-top:8px">
        <div style="flex:1">
          <h4>Words (Wordscapes)</h4>
          <div id="wordsList">Words will load here (from dental_words.json)</div>
          <div style="margin-top:8px">
            <button id="btnReloadWords">Reload words</button>
            <button id="btnClearWordProgress" class="home-btn">Clear Word Progress</button>
          </div>
        </div>

        <div style="width:320px">
          <h4>Quiz & Cases</h4>
          <div>Quiz questions: <span id="quizCount">-</span></div>
          <div>Cases: <span id="casesCount">-</span></div>
          <div style="margin-top:8px">
            <button id="btnClearQuizProgress" class="home-btn">Clear Quiz Progress</button>
            <button id="btnClearCasesProgress" class="home-btn">Clear Cases Progress</button>
          </div>
        </div>
      </div>
    </section>

    <section id="gameScreen" style="display:none" class="game-area">
      <button id="btnBackHome" class="home-btn">← Home</button>

      <div id="modeHeader" style="margin-top:12px">
        <h3 id="modeTitle"></h3>
        <div class="small" id="modeSub"> </div>
      </div>

      <div id="contentArea" style="margin-top:12px"></div>

      <div style="display:flex;align-items:center;gap:12px;margin-top:12px">
        <button id="prevBtn" class="home-btn">⬅ Previous</button>
        <div id="doneIndicator" class="indicator"></div>
        <div style="flex:1"></div>
        <div id="timerDisplay" class="small"></div>
      </div>
    </section>

    <footer>
      <div>Features: JSON loading, save/resume per mode, background music + SFX, auto-next on timeout, previous button, answered indicator.</div>
    </footer>
  </main>

<script>
/* =======================
   CONFIG: filenames & keys
   ======================= */
const DATA_ROOT = './'; // change if your .json is hosted elsewhere
const WORDS_FILE = DATA_ROOT + 'dental_words.json';
const QUIZ_FILE  = DATA_ROOT + 'dental_quiz.json';
const CASES_FILE = DATA_ROOT + 'dental_cases.json';

const KEY_WORD_PROGRESS = 'wordscapes_v1';
const KEY_QUIZ_PROGRESS = 'quiz_v1';
const KEY_CASES_PROGRESS = 'cases_v1';
const AUDIO_PREF_KEY    = 'dg_audio_muted_v1';

/* =========================
   SIMPLE UTILITIES
   ========================= */
const $ = sel => document.querySelector(sel);
const $all = sel => Array.from(document.querySelectorAll(sel));
const wait = ms => new Promise(r=>setTimeout(r,ms));
const shuffle = arr => arr.slice().sort(()=>Math.random()-0.5);

/* =========================
   AUDIO SOURCES (public/free)
   - click: Wikimedia Commons (public domain)
   - correct: Wikimedia Commons (success chime)
   - wrong: orangefreesounds (free)
   - timeout: Actions Google alarm
   - bg music: a short ambient loop (public-source)
   NOTE: you may replace these URLs with your hosted files.
   ========================= */

const AUDIO_URLS = {
  bg:        'https://actions.google.com/sounds/v1/ambiences/office_ambience.ogg',        // ambient loop (actions.google)
  click:     'https://upload.wikimedia.org/wikipedia/commons/1/12/Clickick_switch.ogg',    // public-domain click
  correct:   'https://upload.wikimedia.org/wikipedia/commons/4/4c/En-us-successes.ogg',    // success chime (commons)
  wrong:     'https://orangefreesounds.com/wp-content/uploads/2017/05/Wrong-answer-sound-effect.mp3', // buzzer (orangefreesounds)
  timeout:   'https://actions.google.com/sounds/v1/alarms/digital_watch_alarm_long.ogg'    // alarm (actions.google)
};

/* =========================
   AUDIO MANAGER
   ========================= */
class AudioManager {
  constructor(urls) {
    this.urls = urls;
    this.sounds = {};
    this.muted = (localStorage.getItem(AUDIO_PREF_KEY) === 'true');
  }

  async preload() {
    for (const k of Object.keys(this.urls)) {
      const a = new Audio(this.urls[k]);
      a.preload = 'auto';
      a.volume = (k === 'bg' ? 0.35 : 1.0);
      a.loop = (k === 'bg');
      // don't auto-play; wait until user triggers
      this.sounds[k] = a;
      // add canplay listener to ensure ready
      await new Promise(resolve => {
        const once = () => { a.removeEventListener('canplay', once); resolve(); };
        a.addEventListener('canplay', once);
        // if already buffered, resolve
        setTimeout(()=>resolve(), 2000);
      });
    }
  }

  play(name) {
    if (this.muted) return;
    const s = this.sounds[name];
    if (!s) return;
    // must handle play promise
    s.currentTime = 0;
    s.play().catch(()=>{ /* ignored: browser might block until user gesture */ });
  }

  playOnce(name) {
    // useful for short clicks: clone to avoid cutting other plays
    if (this.muted) return;
    const url = this.urls[name];
    if (!url) return;
    const a = new Audio(url);
    a.volume = (name === 'bg' ? 0.3 : 1.0);
    a.play().catch(()=>{});
  }

  toggleMute() {
    this.muted = !this.muted;
    localStorage.setItem(AUDIO_PREF_KEY, String(this.muted));
    if (this.muted) {
      // pause bg
      this.sounds.bg && this.sounds.bg.pause();
    } else {
      // resume bg
      this.sounds.bg && this.sounds.bg.play().catch(()=>{});
    }
  }

  startBG() {
    if (!this.sounds.bg) return;
    if (!this.muted) this.sounds.bg.play().catch(()=>{});
  }
}
const audio = new AudioManager(AUDIO_URLS);

/* =========================
   DATA STORAGE
   ========================= */
let words = [];      // array of WORDSCAPES words (strings)
let quizData = [];   // array of {question, options, answer}
let casesData = [];  // array of {case, options, answer}

/* =========================
   UI refs
   ========================= */
const homeScreen = $('#homeScreen');
const gameScreen = $('#gameScreen');
const contentArea = $('#contentArea');
const wordsList = $('#wordsList');
const quizCountEl = $('#quizCount');
const casesCountEl = $('#casesCount');
const modeTitle = $('#modeTitle');
const modeSub = $('#modeSub');
const doneIndicator = $('#doneIndicator');
const prevBtn = $('#prevBtn');
const timerDisplay = $('#timerDisplay');

/* =========================
   GAME STATE (for each mode)
   ========================= */
let currentMode = null; // 'wordscapes' | 'quiz' | 'cases'

let wordState = { index: 0 };
let quizState = { index: 0, score: 0, answeredSet: new Set(), unansweredStack: [] };
let casesState = { index: 0, answeredSet: new Set(), unansweredStack: [] };

let countdownTimer = null;
let countdownRemaining = 0;

/* =========================
   LOAD JSON (graceful)
   ========================= */
async function loadJSON(url) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('Not ok');
    return await res.json();
  } catch (err) {
    console.error('Failed to load', url, err);
    return null;
  }
}

/* =========================
   INIT: preload audio + data
   ========================= */
async function init() {
  // preload audio (but it will only actually play after user taps Play Audio)
  audio.preload().catch(()=>console.warn('audio preload failed'));

  // load data
  const [w, q, c] = await Promise.all([
    loadJSON(WORDS_FILE),
    loadJSON(QUIZ_FILE),
    loadJSON(CASES_FILE)
  ]);

  if (Array.isArray(w)) {
    // keep uppercase words if user requested earlier
    words = w.map(x => (typeof x === 'string' ? x.toUpperCase() : (x.word || '').toUpperCase())).filter(Boolean);
    wordsList.textContent = words.join('\n');
  } else {
    wordsList.textContent = 'Could not load dental_words.json — make sure you serve via http:// (web server).';
  }

  if (Array.isArray(q)) {
    quizData = q;
    quizCountEl.textContent = quizData.length;
  } else quizCountEl.textContent = '0';

  if (Array.isArray(c)) {
    casesData = c;
    casesCountEl.textContent = casesData.length;
  } else casesCountEl.textContent = '0';

  // load saved progress
  loadProgressAll();
}

/* =========================
   SAVE / LOAD PROGRESS
   ========================= */
function saveWordProgress() {
  localStorage.setItem(KEY_WORD_PROGRESS, JSON.stringify(wordState));
}
function saveQuizProgress() {
  // convert set to array
  const payload = { index: quizState.index, score: quizState.score, answered: Array.from(quizState.answeredSet) };
  localStorage.setItem(KEY_QUIZ_PROGRESS, JSON.stringify(payload));
}
function saveCasesProgress() {
  const payload = { index: casesState.index, answered: Array.from(casesState.answeredSet) };
  localStorage.setItem(KEY_CASES_PROGRESS, JSON.stringify(payload));
}

function loadProgressAll() {
  try {
    const wd = JSON.parse(localStorage.getItem(KEY_WORD_PROGRESS) || 'null');
    if (wd && typeof wd.index === 'number') wordState.index = wd.index;
    const qd = JSON.parse(localStorage.getItem(KEY_QUIZ_PROGRESS) || 'null');
    if (qd) {
      quizState.index = Number(qd.index || 0);
      quizState.score = Number(qd.score || 0);
      quizState.answeredSet = new Set(qd.answered || []);
    }
    const cd = JSON.parse(localStorage.getItem(KEY_CASES_PROGRESS) || 'null');
    if (cd) {
      casesState.index = Number(cd.index || 0);
      casesState.answeredSet = new Set(cd.answered || []);
    }
  } catch (e) {
    console.warn('loadProgressAll error', e);
  }
}

/* =========================
   UI NAVIGATION
   ========================= */

$('#btnWordscapes').addEventListener('click', ()=>openMode('wordscapes'));
$('#btnQuiz').addEventListener('click', ()=>openMode('quiz'));
$('#btnCases').addEventListener('click', ()=>openMode('cases'));
$('#btnBackHome').addEventListener('click', ()=>{ stopAllTimers(); showHome(); saveAll(); });
$('#btnReloadWords').addEventListener('click', ()=>{ init(); audio.playOnce('click'); });
$('#btnClearWordProgress').addEventListener('click', ()=>{ localStorage.removeItem(KEY_WORD_PROGRESS); wordState = {index:0}; audio.playOnce('click'); alert('Word progress cleared'); });
$('#btnClearQuizProgress').addEventListener('click', ()=>{ localStorage.removeItem(KEY_QUIZ_PROGRESS); quizState = {index:0,score:0,answeredSet:new Set()}; audio.playOnce('click'); alert('Quiz progress cleared'); });
$('#btnClearCasesProgress').addEventListener('click', ()=>{ localStorage.removeItem(KEY_CASES_PROGRESS); casesState = {index:0,answeredSet:new Set()}; audio.playOnce('click'); alert('Cases progress cleared'); });

$('#btnPlayAudio').addEventListener('click', async function() {
  // attempt to start background audio (user gesture)
  await audio.preload().catch(()=>{});
  audio.muted = false;
  audio.startBG();
  $('#btnToggleMute').classList.remove('muted');
  this.disabled = true;
  this.textContent = 'Audio Playing';
});

$('#btnToggleMute').addEventListener('click', function() {
  audio.toggleMute();
  if (audio.muted) {
    this.classList.add('muted');
    this.textContent = 'Muted';
  } else {
    this.classList.remove('muted');
    this.textContent = 'Unmuted';
  }
});

/* =========================
   SAVE ALL (helper)
   ========================= */
function saveAll() {
  saveWordProgress();
  saveQuizProgress();
  saveCasesProgress();
}

/* =========================
   SHOW HOME
   ========================= */
function showHome() {
  currentMode = null;
  homeScreen.style.display = '';
  gameScreen.style.display = 'none';
  audio.playOnce('click');
}

/* =========================
   OPEN MODE
   ========================= */
function openMode(mode) {
  audio.playOnce('click');
  currentMode = mode;
  homeScreen.style.display = 'none';
  gameScreen.style.display = '';
  // setup mode UI
  if (mode === 'wordscapes') startWordscapes();
  if (mode === 'quiz') startQuiz();
  if (mode === 'cases') startCases();
}

/* =========================
   TIMERS / COUNTDOWN
   ========================= */
function startCountdown(seconds, onTick, onDone) {
  stopAllTimers();
  countdownRemaining = seconds;
  timerDisplay.textContent = formatTime(countdownRemaining);
  countdownTimer = setInterval(()=>{
    countdownRemaining--;
    if (onTick) onTick(countdownRemaining);
    timerDisplay.textContent = formatTime(countdownRemaining);
    if (countdownRemaining <= 0) {
      stopAllTimers();
      if (onDone) onDone();
    }
  }, 1000);
}
function stopAllTimers() {
  if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; timerDisplay.textContent = ''; }
}
function formatTime(s) {
  if (s <= 0) return '00:00';
  const mm = Math.floor(s/60).toString().padStart(2,'0');
  const ss = (s%60).toString().padStart(2,'0');
  return `${mm}:${ss}`;
}

/* =========================
   WORDSCAPES MODE
   ========================= */
function startWordscapes() {
  modeTitle.textContent = 'Wordscapes (Dental words)';
  modeSub.textContent = `Words: ${words.length} • Progress saved automatically`;
  renderWordscapes();
}

function renderWordscapes() {
  stopAllTimers();
  const idx = Math.max(0, Math.min(wordState.index, words.length-1));
  wordState.index = idx;
  saveWordProgress();

  contentArea.innerHTML = '';
  const h = document.createElement('div');
  h.innerHTML = `<h4>Word ${idx+1} of ${words.length}</h4>
                 <div id="wWord" style="font-size:26px;font-weight:700;margin:10px 0">${words[idx] || '(no word)'}</div>
                 <div class="small">This mode simply displays the word list for Wordscapes — you can adapt the game logic here.</div>
                 <div style="margin-top:10px">
                    <button id="wordPrev">Prev</button>
                    <button id="wordNext" style="margin-left:8px">Next</button>
                 </div>`;
  contentArea.appendChild(h);

  $('#wordPrev').addEventListener('click', ()=>{ if (wordState.index>0) wordState.index--; saveWordProgress(); audio.playOnce('click'); renderWordscapes(); });
  $('#wordNext').addEventListener('click', ()=>{ if (wordState.index < words.length -1) wordState.index++; saveWordProgress(); audio.playOnce('click'); renderWordscapes(); });
}

/* =========================
   QUIZ MODE
   ========================= */
function startQuiz() {
  modeTitle.textContent = 'Dental Quiz';
  modeSub.textContent = `Questions: ${quizData.length} • Score: ${quizState.score}`;
  renderQuizQuestion();
}

function renderQuizQuestion() {
  stopAllTimers();
  contentArea.innerHTML = '';

  if (quizData.length === 0) {
    contentArea.textContent = 'No quiz questions loaded.';
    return;
  }

  // clamp index
  if (quizState.index < 0) quizState.index = 0;
  if (quizState.index >= quizData.length) quizState.index = 0;

  const q = quizData[quizState.index];
  const questionEl = document.createElement('div');
  questionEl.innerHTML = `<h4>Q ${quizState.index+1} / ${quizData.length}</h4>
    <div style="font-weight:700;margin:6px 0">${q.question}</div>`;
  contentArea.appendChild(questionEl);

  const optWrap = document.createElement('div');
  optWrap.className = 'options';
  contentArea.appendChild(optWrap);

  // indicator & prev logic
  doneIndicator.textContent = quizState.answeredSet.has(quizState.index) ? '✅ Answered' : '❌ Not answered';
  prevBtn.onclick = () => {
    if (quizState.index > 0) { quizState.index--; saveQuizProgress(); renderQuizQuestion(); audio.playOnce('click'); }
  };

  // show options shuffled
  const opts = shuffle(q.options || []);
  for (const opt of opts) {
    const b = document.createElement('button');
    b.className = 'option-btn';
    b.textContent = opt;
    b.onclick = async () => {
      // disable buttons
      Array.from(optWrap.querySelectorAll('button')).forEach(x=>x.disabled = true);
      stopAllTimers();

      quizState.answeredSet.add(quizState.index);
      if (opt.trim().toLowerCase() === q.answer.trim().toLowerCase()) {
        audio.playOnce('correct');
        quizState.score += 10;
        modeSub.textContent = `Questions: ${quizData.length} • Score: ${quizState.score}`;
      } else {
        audio.playOnce('wrong');
      }
      // mark answered & save
      saveQuizProgress();
      await wait(650);
      // go to next
      quizState.index = (quizState.index + 1) % quizData.length;
      saveQuizProgress();
      renderQuizQuestion();
    };
    optWrap.appendChild(b);
  }

  // start countdown: 20 seconds per question
  startCountdown(20, null, ()=> {
    // time's up: play sound, mark unanswered (not answered), advance
    audio.playOnce('timeout');
    // don't add to answeredSet: leave as unanswered so user can come back
    quizState.unansweredStack = quizState.unansweredStack || [];
    quizState.unansweredStack.push(quizState.index);
    quizState.index = (quizState.index + 1) % quizData.length;
    saveQuizProgress();
    renderQuizQuestion();
  });
}

/* =========================
   CASES MODE (similar to quiz, but case text)
   ========================= */
function startCases() {
  modeTitle.textContent = 'Dental Case Scenarios';
  modeSub.textContent = `Cases: ${casesData.length}`;
  renderCaseQuestion();
}

function renderCaseQuestion() {
  stopAllTimers();
  contentArea.innerHTML = '';

  if (casesData.length === 0) {
    contentArea.textContent = 'No cases loaded.';
    return;
  }

  // clamp index
  if (casesState.index < 0) casesState.index = 0;
  if (casesState.index >= casesData.length) casesState.index = 0;

  const c = casesData[casesState.index];
  const questionEl = document.createElement('div');
  questionEl.innerHTML = `<h4>Case ${casesState.index+1} / ${casesData.length}</h4>
    <div style="font-weight:700;margin:6px 0">${c.case}</div>`;
  contentArea.appendChild(questionEl);

  const optWrap = document.createElement('div');
  optWrap.className = 'options';
  contentArea.appendChild(optWrap);

  doneIndicator.textContent = casesState.answeredSet.has(casesState.index) ? '✅ Answered' : '❌ Not answered';
  prevBtn.onclick = () => {
    if (casesState.index > 0) { casesState.index--; saveCasesProgress(); renderCaseQuestion(); audio.playOnce('click'); }
  };

   const opts = shuffle(c.options || []);
  for (const opt of opts) {
    const b = document.createElement('button');
    b.className = 'option-btn';
    b.textContent = opt;
    b.onclick = async () => {
      Array.from(optWrap.querySelectorAll('button')).forEach(x=>x.disabled = true);
      stopAllTimers();

      casesState.answeredSet.add(casesState.index);
      if (opt.trim().toLowerCase() === c.answer.trim().toLowerCase()) audio.playOnce('correct');
      else audio.playOnce('wrong');

      saveCasesProgress();
      await wait(650);
      casesState.index = (casesState.index + 1) % casesData.length;
      saveCasesProgress();
      renderCaseQuestion();
    };
    optWrap.appendChild(b);
  }

  // countdown 30s for cases (example)
  startCountdown(30, null, ()=> {
    audio.playOnce('timeout');
    casesState.unansweredStack = casesState.unansweredStack || [];
    casesState.unansweredStack.push(casesState.index);
    casesState.index = (casesState.index + 1) % casesData.length;
    saveCasesProgress();
    renderCaseQuestion();
  });
}

/* =========================
   ON LOAD
   ========================= */
window.addEventListener('load', async ()=> {
  await init();
  showHome();
});

/* =========================
   VISIBILITY: resume BG when returning
   ========================= */
document.addEventListener('visibilitychange', ()=> {
  if (!document.hidden) {
    audio.startBG();
  } else {
    // optional: pause bg when user leaves
    // audio.sounds.bg && audio.sounds.bg.pause();
  }
});

/* =========================
   graceful beforeunload: save progress
   ========================= */
window.addEventListener('beforeunload', ()=>{
  saveAll();
});
</script>
</body>
</html>
